// <auto-generated/>
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace GitHub.Models
{
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.17.0")]
    #pragma warning disable CS1591
    public partial class RepositoryRuleMergeQueue_parameters : IAdditionalDataHolder, IParsable
    #pragma warning restore CS1591
    {
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>Maximum time for a required status check to report a conclusion. After this much time has elapsed, checks that have not reported a conclusion will be assumed to have failed</summary>
        public int? CheckResponseTimeoutMinutes { get; set; }
        /// <summary>When set to ALLGREEN, the merge commit created by merge queue for each PR in the group must pass all required checks to merge. When set to HEADGREEN, only the commit at the head of the merge group, i.e. the commit containing changes from all of the PRs in the group, must pass its required checks to merge.</summary>
        public global::GitHub.Models.RepositoryRuleMergeQueue_parameters_grouping_strategy? GroupingStrategy { get; set; }
        /// <summary>Limit the number of queued pull requests requesting checks and workflow runs at the same time.</summary>
        public int? MaxEntriesToBuild { get; set; }
        /// <summary>The maximum number of PRs that will be merged together in a group.</summary>
        public int? MaxEntriesToMerge { get; set; }
        /// <summary>Method to use when merging changes from queued pull requests.</summary>
        public global::GitHub.Models.RepositoryRuleMergeQueue_parameters_merge_method? MergeMethod { get; set; }
        /// <summary>The minimum number of PRs that will be merged together in a group.</summary>
        public int? MinEntriesToMerge { get; set; }
        /// <summary>The time merge queue should wait after the first PR is added to the queue for the minimum group size to be met. After this time has elapsed, the minimum group size will be ignored and a smaller group will be merged.</summary>
        public int? MinEntriesToMergeWaitMinutes { get; set; }
        /// <summary>
        /// Instantiates a new <see cref="global::GitHub.Models.RepositoryRuleMergeQueue_parameters"/> and sets the default values.
        /// </summary>
        public RepositoryRuleMergeQueue_parameters()
        {
            AdditionalData = new Dictionary<string, object>();
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::GitHub.Models.RepositoryRuleMergeQueue_parameters"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::GitHub.Models.RepositoryRuleMergeQueue_parameters CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
            return new global::GitHub.Models.RepositoryRuleMergeQueue_parameters();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "check_response_timeout_minutes", n => { CheckResponseTimeoutMinutes = n.GetIntValue(); } },
                { "grouping_strategy", n => { GroupingStrategy = n.GetEnumValue<global::GitHub.Models.RepositoryRuleMergeQueue_parameters_grouping_strategy>(); } },
                { "max_entries_to_build", n => { MaxEntriesToBuild = n.GetIntValue(); } },
                { "max_entries_to_merge", n => { MaxEntriesToMerge = n.GetIntValue(); } },
                { "merge_method", n => { MergeMethod = n.GetEnumValue<global::GitHub.Models.RepositoryRuleMergeQueue_parameters_merge_method>(); } },
                { "min_entries_to_merge", n => { MinEntriesToMerge = n.GetIntValue(); } },
                { "min_entries_to_merge_wait_minutes", n => { MinEntriesToMergeWaitMinutes = n.GetIntValue(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            _ = writer ?? throw new ArgumentNullException(nameof(writer));
            writer.WriteIntValue("check_response_timeout_minutes", CheckResponseTimeoutMinutes);
            writer.WriteEnumValue<global::GitHub.Models.RepositoryRuleMergeQueue_parameters_grouping_strategy>("grouping_strategy", GroupingStrategy);
            writer.WriteIntValue("max_entries_to_build", MaxEntriesToBuild);
            writer.WriteIntValue("max_entries_to_merge", MaxEntriesToMerge);
            writer.WriteEnumValue<global::GitHub.Models.RepositoryRuleMergeQueue_parameters_merge_method>("merge_method", MergeMethod);
            writer.WriteIntValue("min_entries_to_merge", MinEntriesToMerge);
            writer.WriteIntValue("min_entries_to_merge_wait_minutes", MinEntriesToMergeWaitMinutes);
            writer.WriteAdditionalData(AdditionalData);
        }
    }
}
